---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# %autosave 0
```

### Generate the Wadden Sea initial and forcing data file

```{python}
# %matplotlib inline 

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import xarray as xr
```

#### Read a World Ocean Database (WOD) nc file which is produced by Ocean Data Viewer (ODV) and smooth through years for depths less then 11 m, var1 is depth

```{python}
ds = xr.open_dataset('wadden_sea.nc')
df = ds.to_dataframe()
df = df[(df.date_time > '2000-01-01 00:00:00.0') & (df.var1 < 11)]
df = df[['longitude', 'latitude', 'date_time'
        ,'var1', 'var2', 'var3', 'var4', 'var5', 'var6', 'var7'
        ,'var8', 'var9', 'var10', 'var11', 'var12', 'var13', 'var14']]
df.columns = ['longitude', 'latitude', 'date_time'
             ,'Depth', 'Temperature', 'Salinity', 'Oxygen', 'Phosphate', 'Silicate', 'Nitrate'
             ,'Nitrite', 'pH', 'Chlorophyll a', 'Plankton biomass', 'Alkalinity', 'NO2+NO3', 'pCO2']
df['Oxygen'] = df['Oxygen']*44.661 # 1 ml/l = 10^3/22.391 = 44.661 μmol/l
df['Day of year'] = df.date_time.dt.dayofyear.values
```

#### Make a mean year from a range of 11 years

```{python}
dfyear = df[(df.date_time > '2000-01-01 00:00:00.0') & (df.date_time < '2011-01-01 00:00:00.0')]
dfyear = dfyear.groupby(['Day of year']).mean()
dfyear = dfyear.reindex(index=range(1,366))
```

```{python}
dfyear = dfyear.interpolate(method='linear',limit_direction='forward')
dfyear.loc[0:16,:] = dfyear[-1:].values
dfyear.loc[0:16,'Chlorophyll a'] = 0
dfyear = dfyear.interpolate(method='linear',limit_direction='both')
dfyear = dfyear.rolling(window=16).mean()
dfyear = dfyear.interpolate(method='linear',limit_direction='both')
```

#### Make three successive years from one and plot, other parameters also will be produced for 3 succesive similar years to construct a nc file with input data for a fortran model which resolves water and sediments domains

```{python}
df3years = dfyear.append([dfyear, dfyear])
df3years.index = range(1, len(df3years)+1)
df3years.index.name = "day"
```

```{python}
name = 'Chlorophyll a'
plt.plot(df3years.index, df3years[name]); plt.gcf().set_size_inches(10,2);
plt.title(name); plt.xlabel('Day'); plt.ylabel(name);
```

#### Plot dfyear, just visualization

```{python}
name = 'Chlorophyll a'
plt.plot(dfyear.index, dfyear[name]); plt.gcf().set_size_inches(10,2);
plt.title(name); plt.xlabel('Day'); plt.ylabel(name);
```

```{python}
name = 'Oxygen'
plt.plot(dfyear.index, dfyear[name]); plt.gcf().set_size_inches(10,2);
plt.title(name); plt.xlabel('Day'); plt.ylabel(name);
```

#### Read and process a text file downloaded from http://tsdata.hzg.de/ (Pile Hoernum1 station) with photosynthetically active radiation (PAR) data

```{python}
dfpar = pd.read_csv('Pile_Hoernum1_PAR_20080101_20180608.dat', header=None, delim_whitespace=True
                   , skiprows=22)
dfpar[0] = dfpar[0] + ' ' + dfpar[1]
dfpar = dfpar.drop(1, axis=1)
dfpar[0] =  pd.to_datetime(dfpar[0])
dfpar = dfpar.rename(columns={0: 'date_time', 2: 'par', 3: 'flag'})
dfpar = dfpar[(dfpar['flag'] < 3) & (dfpar['par'] > 0)]
dfpar = dfpar.drop('flag', axis=1)
dfpar['Day of year'] = dfpar.date_time.dt.dayofyear.values
dfparmean = dfpar.groupby(['Day of year']).mean()
dfparmean = dfparmean.reindex(index=range(1,366))
```

```{python}
dfparmean = dfparmean.interpolate(method='linear',limit_direction='both')
dfparmean = dfparmean.rolling(window=16).mean()
dfparmean = dfparmean.interpolate(method='linear',limit_direction='both')
```

```{python}
# use a function described in utilities.py to generate a theoretical PAR
import utilities as ut
par_generated = np.zeros(365)
par_generated[:] = [ut.surface_radiation(x, 54) for x in range(365)]
```

```{python}
par3years_generated = np.concatenate((par_generated, par_generated, par_generated), axis=None)
```

```{python}
# visualize measured PAR
name = 'par'; plt.plot(dfparmean.index, dfparmean[name]);
plt.gcf().set_size_inches(10,2); plt.title(name);
plt.xlabel('Day'); plt.ylabel('$\mu M\,s^{-1}\,m^{-2}$');
```

```{python}
# visualize calculated PAR
name = 'par'; plt.plot(dfparmean.index, par_generated);
plt.gcf().set_size_inches(10,2); plt.title(name);
plt.xlabel('Day'); plt.ylabel('$\mu M\,s^{-1}\,m^{-2}$');
```

#### Generate yearly organic matter (OM) and gross primary production (gpp) according to Beusekom (1999)

```{python}
from scipy import integrate
```

The original flux of OM is 110 $gC\,m^{-2} y^{-1}$ for the total water column, the Wadden sea has an average depth 2.5 meters, so concentration is 110/2.5 for each layer.

```{python}
annual_flux_om = 110/2.5 * 1000# mg C m-3 d-1
#annual_flux_don = ((110/2.5)/12.011) * 1000 * (16/106)# mM N m-3 d-1
```

The same for gpp, initial value is 309 $gC\,m^{-2} y^{-1}$

```{python}
gpp = 309/2.5 * 1000# mg C m-3 d-1
#gpp = ((309/2.5)/12.011) * 1000 * (16/106)# mM N m-3 d-1
```

Function for parameter 'm' identification (maximum) with given total yearly value according to simplification that OM influx or gpp has an approximately sinusoidal yearly profile

```{python}
def sinusoidal(fr, ti, st, var):
    """fr - lower bound of the parameter
       ti - upper bound of the parameter
       st - step for the parameter selection
       var - the value of the assessed sinusoidal integral"""
    for m in np.arange(fr, ti, st):
        flux = lambda day: m/16 + (m/2)*(1+np.sin(2*np.pi*(day-40)/365))
        sumflux = integrate.quad(flux, 0, 365)
        if var-1 < sumflux[0] < var+1:
            print(m)
```

#### OM

```{python}
sinusoidal(200,300,0.01,annual_flux_om) # finds a maximum value of yearly OM influx
```

```{python}
m = 214.31
day = np.arange(0,1095,1)
# use sinusoidal function to produce yearly profile of OM influx
y_om = m/16 + (m/2)*(1+np.sin(2*np.pi*(day-40)/365))
```

```{python}
plt.plot(np.arange(0,365,1), y_om[0:365]); plt.gcf().set_size_inches(10,2);
plt.title('OM influx'); plt.xlabel('Day');
plt.ylabel('$mg\,C\,day^{-1}\,m^{-3}$');
```

#### GPP

```{python}
sinusoidal(500,900,0.01,gpp) # returns maximum value of yearly gpp
```

```{python}
m = 602.01
day = np.arange(0,1095,1)
# the same sinusoidal
y_gpp = m/16 + (m/2)*(1+np.sin(2*np.pi*(day-40)/365))
```

```{python}
plt.plot(np.arange(0,365,1), y_gpp[0:365]); plt.gcf().set_size_inches(10,2);
plt.title('gpp'); plt.xlabel('Day');
plt.ylabel('$mg\,C\,day^{-1}\,m^{-3}$');
```

#### Generate a wadden_sea_out.nc file which consist of 3 successive similar years

```{python}
import utilities as ut
import itertools as it
from netCDF4 import Dataset

rootgrp = Dataset("wadden_sea_out.nc", "w", format='NETCDF3_CLASSIC')

levelface = rootgrp.createDimension("levelface", 3)
levelcntr = rootgrp.createDimension("levelcntr", 2)
time = rootgrp.createDimension("time", 1095)

times = rootgrp.createVariable("time","f8",("time",))
times.units = "seconds since 2010-01-01 00:00:00.0"
times.calendar = "gregorian"

par = rootgrp.createVariable("par","f4",("time",))
par.units = "microM photons m−2 s−1"

hice = rootgrp.createVariable("hice","f4",("time",))
snowthick = rootgrp.createVariable("snowthick","f4",("time",))
icesurft = rootgrp.createVariable("icesurft","f4",("time",))

levelsface = rootgrp.createVariable("levelface","f4",("levelface",))
levelsface.units = "m"
levelscntr = rootgrp.createVariable("levelcntr","f4",("levelcntr",))
levelscntr.units = "m"
temperature = rootgrp.createVariable("temperature","f8",("time","levelcntr",))
temperature.units = "C degrees"
salinity = rootgrp.createVariable("salinity","f8",("time","levelcntr",))
salinity.units = "psu"
sigma = rootgrp.createVariable("sigma","f8",("time","levelcntr",))
sigma.units = "kg m-1"
turbulence = rootgrp.createVariable("turbulence","f8",("time","levelface",))
turbulence.units = "m2 s-1"

ammonium = rootgrp.createVariable("ammonium","f8",("time","levelcntr",))
ammonium.units = "mM N m-3"
nitrate = rootgrp.createVariable("nitrate","f8",("time","levelcntr",))
nitrate.units = "mM N m-3"
sulfate = rootgrp.createVariable("sulfate","f8",("time","levelcntr",))
nitrate.units = "mM S m-3"
silicate = rootgrp.createVariable("silicate","f8",("time","levelcntr",))
silicate.units = "mM Si m-3"
phosphate = rootgrp.createVariable("phosphate","f8",("time","levelcntr",))
phosphate.units = "mM P m-3"
oxygen = rootgrp.createVariable("oxygen","f8",("time","levelcntr",))
oxygen.units = "mM O2 m-3"
om = rootgrp.createVariable("om_flux","f8",("time","levelcntr",))
om.units = "mg C m-3 s-1"
chl_a = rootgrp.createVariable("chl_a","f8",("time","levelcntr",))
chl_a.units = "mg Chl a"

lvlface = np.array([2.5, 1.25, 0])
lvlcntr = np.array([1.875, 0.625])

levelsface[:] = lvlface
levelscntr[:] = lvlcntr

times[:] = df3years.index.values * 24 * 60 * 60
par[:] = par3years_generated
hice[:] = 0
snowthick[:] = 0
icesurft[:] = 0
temperature[:,:] = np.vstack((df3years.Temperature.values, df3years.Temperature.values)).T
salinity[:,:] = np.vstack((df3years.Salinity.values, df3years.Salinity.values)).T
```

#### Calculate eddy diffusivity, see utilities.py

```{python}
sigma[:,0] = [ut.svan(s,t,p) for s,t,p in 
              zip(df3years.Salinity.values, df3years.Temperature.values, it.count(lvlcntr[0]))]
sigma[:,1] = [ut.svan(s,t,p) for s,t,p in 
              zip(df3years.Salinity.values, df3years.Temperature.values, it.count(lvlcntr[1]))]
```

```{python}
sigmaface = np.zeros((1095,3))
sigmaface[:,0] = [ut.svan(s,t,p) for s,t,p in 
              zip(df3years.Salinity.values, df3years.Temperature.values, it.count(lvlface[0]))]
sigmaface[:,1] = [ut.svan(s,t,p) for s,t,p in 
              zip(df3years.Salinity.values, df3years.Temperature.values, it.count(lvlface[1]))]
sigmaface[:,2] = [ut.svan(s,t,p) for s,t,p in 
              zip(df3years.Salinity.values, df3years.Temperature.values, it.count(lvlface[2]))]
turbulence[:,0] = ut.gargett(sigmaface[:,0], 1)
turbulence[:,1] = ut.gargett(sigmaface[:,1], 1)
turbulence[:,2] = ut.gargett(sigmaface[:,2], 1)
```

```{python}
ammonium[:,:] = 0.1
sulfate[:,:] = 25000
nitrate[:,:] = np.vstack((df3years.Nitrate.values, df3years.Nitrate.values)).T
silicate[:,:] = np.vstack((df3years.Silicate.values, df3years.Silicate.values)).T
phosphate[:,:] = np.vstack((df3years.Phosphate.values, df3years.Phosphate.values)).T
oxygen[:,:] = np.vstack((df3years.Oxygen.values, df3years.Oxygen.values)).T
```

```{python}
chl_a[:,:] = np.vstack((df3years['Chlorophyll a'].values, df3years['Chlorophyll a'].values)).T
```

```{python}
om[:,:] = np.vstack((y_om/86400, y_om/86400)).T
```

```{python}
rootgrp.close()
```

```{python}

```
